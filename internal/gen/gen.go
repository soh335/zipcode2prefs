package main

import (
	"archive/zip"
	"bytes"
	"encoding/csv"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"sort"
	"strings"

	"golang.org/x/text/encoding/japanese"
	"golang.org/x/text/transform"
)

var output = flag.String("output", "zipcode2prefs.gen.go", "output path")

// generate zipcode => pref list
func main() {
	if err := _main(); err != nil {
		log.Fatal(err)
	}
}

func _main() error {
	var src io.Reader
	if len(os.Args) == 1 {
		u := "https://www.post.japanpost.jp/zipcode/dl/kogaki/zip/ken_all.zip"
		req, err := http.NewRequest("GET", u, nil)
		if err != nil {
			return fmt.Errorf("%w", err)
		}
		req.Header.Set("User-Agent", "https://github.com/soh335/zipcode2prefs")

		fmt.Printf("download %s\n", u)
		res, err := http.DefaultClient.Do(req)
		if err != nil {
			return fmt.Errorf("%w", err)
		}
		defer res.Body.Close()
		if res.StatusCode != http.StatusOK {
			return fmt.Errorf("status code:%d", res.StatusCode)
		}

		body, err := ioutil.ReadAll(res.Body)
		if err != nil {
			return fmt.Errorf("%w", err)
		}
		zipr, err := zip.NewReader(bytes.NewReader(body), int64(len(body)))
		if err != nil {
			return fmt.Errorf("%w", err)
		}
		fr, err := zipr.File[0].Open()
		if err != nil {
			return fmt.Errorf("%w", err)
		}
		defer fr.Close()
		src = fr
	} else {
		f, err := os.Open(os.Args[1])
		if err != nil {
			return err
		}
		defer f.Close()
		src = f
	}

	r := csv.NewReader(transform.NewReader(src, japanese.ShiftJIS.NewDecoder()))

	prefs := map[string][]string{}

	for {
		records, err := r.Read()
		if err != nil {
			if errors.Is(err, io.EOF) {
				break
			}
			return fmt.Errorf("%w", err)
		}
		zipcode := records[2]
		pref := records[6]
		if _, ok := prefs[zipcode]; !ok {
			prefs[zipcode] = []string{}
		}
		found := false
		for _, p := range prefs[zipcode] {
			if p == pref {
				found = true
				break
			}
		}
		if !found {
			prefs[zipcode] = append(prefs[zipcode], pref)
		}
	}

	keys := make([]string, len(prefs))
	idx := 0
	for y := range prefs {
		keys[idx] = y
		idx++
	}
	sort.Strings(keys)

	var buf bytes.Buffer
	buf.WriteString(`// Code generated by internal/gen/gen.go; DO NOT EDIT.`)
	buf.WriteString("\npackage zipcode2prefs")
	buf.WriteString("\nvar prefs = map[string]string{")
	for _, y := range keys {
		sort.Strings(prefs[y])
		buf.WriteString(fmt.Sprintf("\n\"%s\": \"%s\",", y, strings.Join(prefs[y], ",")))
	}
	buf.WriteString("\n}")
	formated, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return ioutil.WriteFile(*output, formated, 0644)
}
